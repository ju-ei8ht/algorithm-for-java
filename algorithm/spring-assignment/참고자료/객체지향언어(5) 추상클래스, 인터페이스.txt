<java 객체지향언어>

1. 추상클래스 (abstract method)
//추상메소드를 선언할 수 있는 클래스
//클래스랑 다르게 상속받는 자식 클래스 없이 그 자체로 인스턴스를 생성할 수 없다
//예시) Animal과 Dog에서 Animal 타입으로 new Dog를 할 수 있지만
//Animal타입으로 new animal도 할 수 있는데
//Animal이 추상클래스라면 new animal은 할 수 없고 new Dog만 할 수 있다
//추상 메소드는 설계만 되어 있고 구현체가 없는 것
//->return type이 뭐고 함수 이름이 뭐고 파라미터는 뭘 받을 거야 라는 건 선언하지만
//중 괄호{} 안에 있는 블럭 구현체는 없다
//자식클래스에서 모두 구현해야 된다는 걸 의미함
abstract class Bird{
    private int x,y,z;

    void fly(int x, int y, int z){
        printLocation();
        System.out.println("이동합니다.");
        this.x = x;
        this.y = y;
        if(flyable(z)){
           this.z = z;
        }else{
            System.out.println("그 높이로는 날 수 없습니다.");
        }
        printLocation();
    }

    abstract boolean flyable(int z);
    //구현체가 없는데도 abstract class 안에서 진짜 함수처럼 사용됨
    //그런데 내용은 자식(Override된)에 가서 구현이 돼있고
    //자식 객체로 new가 된 다음에는 하나의 코드처럼 실행이 됨

    public void printLocation(){
        System.out.println("현재위치 ("+x+", "+y+", "+z+")");
    }
}

class Pigeon extends Bird {

    @Override
    boolean flyable(int z) {
        return z < 10000;
    }
}

class Peacock extends Bird{

    @Override
    boolean flyable(int z) {
        return false;
    }

}

public class Main {
    public static void main(String[] args) {
        Bird pigeon = new Pigeon();
        Bird peacock = new Peacock();
        System.out.println("--- 비둘기 ---");
        pigeon.fly(1,1,3);
        System.out.println("--- 공작새 ---");
        peacock.fly(1,1,3);
        System.out.println("--- 비둘기 ---");
        pigeon.fly(3,3,30000);
    }
}

=>결과값
--- 비둘기 ---
현재위치 (0, 0, 0)
이동합니다.
현재위치 (1, 1, 3)
--- 공작새 ---
현재위치 (0, 0, 0)
이동합니다.
그 높이로는 날 수 없습니다. //z축 이동을 못하므로
현재위치 (1, 1, 0)
--- 비둘기 ---
현재위치 (1, 1, 3)
이동합니다.
그 높이로는 날 수 없습니다. //z축을 1만 미만까지밖에 이동 못 하므로
현재위치 (3, 3, 3) //원래 z축으로 반환

2. 인터페이스
객체의 특정 행동의 특징을 정의하는 것.
특징: method의 시그니처 접근제어자 return type method 이름만 정의를 하고
함수의 내용은 abstract method 처럼 없다.
인터페이스를 구현하는 클래스는 인터페이스에 존재하는 상세 내용을 반드시 구현해야 한다.
interface Myinterface{
    void myMethod();
}
//이게 기본적인 인터페이스 구조

interface Flyable{
    void fly(int x, int y, int z);
}

class Pigeon implements Flyable {
    private int x,y,z;
    @Override
    public void fly(int x, int y, int z) {
        printLocation();
        System.out.println("날아갑니다.");
        this.x = x;
        this.y = y;
        this.z = z;
        printLocation();
    }

    public void printLocation(){
        System.out.println("현대 위치 ("+x+", "+y+", "+z+")");
    }
}

public class Main {
    public static void main(String[] args) {
        Flyable pigeon = new Pigeon();
        pigeon.fly(1,2,3);
    }
}
//인터페이스는 구현하는 객체의 동작에 명세
//다중상속이 가능하다.
//implements 라는 키워드를 이용해서 구현한다.
//method 시그니처만 선언이 가능하다.

추상클래스는 일반 클래스랑 똑같은데
그것으로 객체를 그 자체로 생성할 순 없다.
클래스 상속과 마찬가지로 extends 키워드를 쓰고
그래서 다중상속이 불가능하다.
추상 method에 대해서만 자식클래스에서 무조건 구현해야 된다.